Это лабораторная про быстрое преобразование Фурье (FFT) и его параллельную реализацию с помощью OpenMP.
сравниваешь медленное DFT (O(n²))
с быстрым FFT (O(n log n))
и смотришь, как FFT масштабируется при увеличении числа потоков
то делает программа в целом
Есть обычное DFT / iDFT — для проверки корректности и понимания
Есть рекурсивный FFT (алгоритм Кули–Тьюки)
FFT распараллелен с помощью:
#pragma omp parallel
#pragma omp task
#pragma omp parallel for
Производится speedtest:
при T = 1..N потоков
несколько запусков
считается среднее время и ускорение
Результаты пишутся в output.csv


DFT и FFT — это способы разложить сигнал на частоты. Ниже — простое и понятное объяснение, без формул «ради математики».

DFT (Discrete Fourier Transform, дискретное преобразование Фурье) — это прямой, «в лоб» способ понять, из каких синусоид состоит сигнал.
Если у тебя есть сигнал во времени (например, набор отсчётов звука), DFT говорит:
какие частоты в нём есть, с какими амплитудами и фазами.

Проблема DFT в том, что оно очень медленное:
для сигнала из n точек требуется примерно n² операций.
При больших n это становится непрактично.

FFT (Fast Fourier Transform, быстрое преобразование Фурье) — это алгоритм ускорения DFT.
Он вычисляет то же самое, что и DFT, но намного быстрее.

Главная идея FFT:

разбить сигнал на чётные и нечётные элементы,

посчитать преобразование для половин,

объединить результаты.

За счёт этого сложность снижается с O(n²) до O(n log n).

Важно:

DFT и FFT дают одинаковый результат

разница только в скорости

FFT особенно эффективно, когда размер сигнала — степень двойки

Почему это важно в твоей лабораторной:

DFT используется как эталон (проверка правильности)

FFT — как быстрый и параллельный алгоритм

OpenMP ускоряет FFT ещё сильнее за счёт распараллеливания

В данной реализации FFT ускорение ограничено, так как размер задачи относительно небольшой, а рекурсивный алгоритм содержит значительные накладные расходы на создание задач и синхронизацию. Для таких задач выигрыш от OpenMP перекрывается издержками параллелизма, поэтому наблюдается лишь небольшое ускорение.